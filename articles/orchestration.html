<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The orchestration and branching model • targets</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="The orchestration and branching model">
<meta property="og:description" content="targets">
<meta property="og:image" content="/logo.svg">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">targets</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
<li>
  <a href="https://wlandau.github.io/targets-manual">Manual</a>
</li>
<li>
  <a href="../articles/index.html">Design</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/wlandau/targets">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="orchestration_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>The orchestration and branching model</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/wlandau/targets/blob/master/vignettes/orchestration.Rmd"><code>vignettes/orchestration.Rmd</code></a></small>
      <div class="hidden name"><code>orchestration.Rmd</code></div>

    </div>

    
    
<p>The <code>targets</code> package runs the correct targets in the correct order (orchestration) and creates new targets dynamically at runtime (branching). This vignette describes the underlying package structure and mental model that gives <code>targets</code> its flexibility and parallel efficiency.</p>
<div id="structure" class="section level1">
<h1 class="hasAnchor">
<a href="#structure" class="anchor"></a>Structure</h1>
<p><code>targets</code> relies heavily on object-oriented programming, and the following subsections describe the hierarchy and composition of the objects relevant to orchestration and branching. Objects that appear once per workflow are instances of <code>R6</code> classes. To maximize performance, target-specific data structures are lower-tech classes: simple environments with formal constructors, helpers, and validators.</p>
<div id="algorithm-class" class="section level2">
<h2 class="hasAnchor">
<a href="#algorithm-class" class="anchor"></a>Algorithm class</h2>
<p>An algorithm in <code>targets</code> is an abstract class that represents how to iterate through the pipeline target by target. Different algorithms describe different kinds of deployment: for example, local execution on the host machine versus parallel execution on a cluster. Every algorithm has a scheduler object and a pipeline object.</p>
</div>
<div id="pipeline-class" class="section level2">
<h2 class="hasAnchor">
<a href="#pipeline-class" class="anchor"></a>Pipeline class</h2>
<p>A pipeline is a wrapper around a collection of targets, and it is responsible for the initial reasoning about the topology of the pipeline before runtime. Pipelines express their reasoning by producing static graphs and scheduler objects early on. In addition, pipelines contain new buds and branches created dynamically during the pipeline.</p>
</div>
<div id="scheduler-class" class="section level2">
<h2 class="hasAnchor">
<a href="#scheduler-class" class="anchor"></a>Scheduler class</h2>
<p>Whereas pipelines are responsible for <em>static</em> topology, schedulers are responsible for <em>dynamic</em> topology. Schedulers know</p>
<ol style="list-style-type: decimal">
<li>The upstream and downstream neighbors of each target.</li>
<li>The progress of each target, e.g. queued, running, or finished.</li>
<li>How many upstream dependencies need to be checked or built before a target is ready to run.</li>
</ol>
<p>To meet these responsibilities, the scheduler is composed of three smaller objects:</p>
<ol style="list-style-type: decimal">
<li>A graph object.</li>
<li>A progress object.</li>
<li>A priority queue.</li>
</ol>
</div>
<div id="graph-class" class="section level2">
<h2 class="hasAnchor">
<a href="#graph-class" class="anchor"></a>Graph class</h2>
<p>The graph class keeps track of the upstream and downstream neighbors of each target. The scheduler adds edges to the graph when new targets are created dynamically.</p>
<p>The graph is implemented as two adjacency lists: one for upstream edges and another for downstream edges. For the purposes of powering a pipeline, we find this low-tech structure to be more efficient than <code>igraph</code> in our situation where we repeatedly query the graph and the number of nodes is small. (Transient <code>igraph</code> objects, however, are created for validation and visualization purposes.)</p>
</div>
<div id="progress-class" class="section level2">
<h2 class="hasAnchor">
<a href="#progress-class" class="anchor"></a>Progress class</h2>
<p>The progress class keeps track of the state of each target: queued, running, skipped, built, outdated, canceled, or errored. To accomplish this, the progress object maintains a counter object for each category.</p>
</div>
<div id="queue-class" class="section level2">
<h2 class="hasAnchor">
<a href="#queue-class" class="anchor"></a>Queue class</h2>
<p>The queue class is a priority queue, essentially a wrapper around a named integer vector of ranks. For <code>targets</code>’ purposes, the rank of a target is the number of unmet dependencies so far, minus a per-target priority value in the interval <code>[0, 1)</code> to control the order in which targets are dequeued. As the pipeline progresses, the queue is checked and modified periodically as dependencies are met. The next target to build is the lowest rank target such that <code>-1L &lt; rank &lt;= 0L</code>. Branches are pushed to the queue when they are dynamically created.</p>
</div>
<div id="counter-class" class="section level2">
<h2 class="hasAnchor">
<a href="#counter-class" class="anchor"></a>Counter class</h2>
<p>A counter is an efficient abstraction for keeping track of target membership in a category. A counter stores the number of targets in the category and a hash table with the names of those targets. Counters are used to efficiently keep track of runtime progress (e.g. running, queued, or built) as well membership in the queue.</p>
</div>
<div id="target-class" class="section level2">
<h2 class="hasAnchor">
<a href="#target-class" class="anchor"></a>Target class</h2>
<p>A target is an abstract class for a step of a pipeline. Each target is a composite of intricate sub-classes that keep track of commands, in-memory dependencies, storage, settings, and some aspects of build behavior. As its name implies, the <code>targets</code> package pushes most of its conceptual complexity to the target level in order to decentralize the architecture and make it much easier to reason about the pipeline as a whole.</p>
<p>There are multiple sub-classes of targets, and the different behaviors of different sub-classes drive the orchestration and branching of targets. The inheritance hierarchy is as follows.</p>
<ul>
<li>Target
<ul>
<li>Bud</li>
<li>Builder
<ul>
<li>Stem</li>
<li>Branch</li>
</ul>
</li>
<li>Pattern
<ul>
<li>Map</li>
<li>Cross</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="stem-class" class="section level2">
<h2 class="hasAnchor">
<a href="#stem-class" class="anchor"></a>Stem class</h2>
<p>A stem is the most basic form of target. It is neither a pattern nor part of a pattern. However, it can dynamically create buds to assist with branching.</p>
</div>
<div id="bud-class" class="section level2">
<h2 class="hasAnchor">
<a href="#bud-class" class="anchor"></a>Bud class</h2>
<p>A bud is a target that simply contains part of a stem’s value in memory. The purpose of a bud is to serve as a dependency of a branch when a pattern branches over a stem.</p>
</div>
<div id="pattern-class" class="section level2">
<h2 class="hasAnchor">
<a href="#pattern-class" class="anchor"></a>Pattern class</h2>
<p>A pattern is an abstract class responsible for creating new branches and dynamically updating the scheduler. Maps and crosses are types of patterns representing different forms of branch creation. Stems and patterns are the only targets the user manually defines in the pipeline.</p>
</div>
<div id="branch-class" class="section level2">
<h2 class="hasAnchor">
<a href="#branch-class" class="anchor"></a>Branch class</h2>
<p>A branch is a target that a pattern creates dynamically at runtime.</p>
</div>
<div id="map-class" class="section level2">
<h2 class="hasAnchor">
<a href="#map-class" class="anchor"></a>Map class</h2>
<p>A map is a pattern that creates branches along a single dimension. If <code>z</code> maps over <code>x</code> (<code>n</code> slices) and <code>y</code> (<code>n</code> slices) ten <code>n</code> branches of <code>z</code> are created, one for each corresponding slice of <code>x</code> and <code>y</code>. The behavior is similar to <code><a href="https://purrr.tidyverse.org/reference/map2.html">purrr::pmap()</a></code>.</p>
</div>
<div id="cross-class" class="section level2">
<h2 class="hasAnchor">
<a href="#cross-class" class="anchor"></a>Cross class</h2>
<p>A cross is a pattern that creates branches in multiple dimensions. If <code>z</code> crosses over <code>x</code> (<code>m</code> slices) and <code>y</code> (<code>n</code> slices) then <code>m * n</code> branches of <code>z</code> are created, one for every unique pair of (<code>x</code>, <code>y</code>) slices.</p>
</div>
<div id="builder-class" class="section level2">
<h2 class="hasAnchor">
<a href="#builder-class" class="anchor"></a>Builder class</h2>
<p>Stems and branches have a lot in common: they actually run R commands, and the write the return values to storage. A builder is an abstract class to contain the heavy lifting that stems and branches both do.</p>
</div>
<div id="junction-class" class="section level2">
<h2 class="hasAnchor">
<a href="#junction-class" class="anchor"></a>Junction class</h2>
<p>A junction is a manifest of the buds or branches (children) that a stem or pattern dynamically creates. Different kinds of patterns (e.g. map and cross) create junctions differently, and this helps <code>targets</code> figure out how to create the right branches with the right dependencies.</p>
</div>
</div>
<div id="orchestration" class="section level1">
<h1 class="hasAnchor">
<a href="#orchestration" class="anchor"></a>Orchestration</h1>
<p>To orchestrate targets, we iterate on the following loop while there is still at least one target in the queue.</p>
<ol style="list-style-type: decimal">
<li>If the target at the head of the queue is not ready to build (rank &gt; 0) sleep for a short time.</li>
<li>If the target at the head of the queue is ready to build (rank = 0) do the following:
<ol style="list-style-type: lower-alpha">
<li>Dequeue the target.</li>
<li>Run the target’s <code>prepare()</code> method.</li>
<li>Run the target’s <code>run()</code> method.</li>
<li>Run the target’s <code>conclude()</code> method to updates the whole scheduler.</li>
<li>Unload transient targets from memory.</li>
</ol>
</li>
</ol>
<p>The usual behavior of <code>prepare()</code>, <code>run()</code>, and <code>conclude()</code> is as follows.</p>
<table class="table">
<colgroup>
<col width="50%">
<col width="50%">
</colgroup>
<thead><tr class="header">
<th>Method</th>
<th>Responsibilities</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>prepare()</code></td>
<td>Announce the target to the console, load dependencies into memory, and register the target as running.</td>
</tr>
<tr class="even">
<td><code>run()</code></td>
<td>Run the R command and create an object to contain the results.</td>
</tr>
<tr class="odd">
<td><code>conclude()</code></td>
<td>Store the value and update the scheduler, create new buds and branches as needed, and register the target as built.</td>
</tr>
</tbody>
</table>
<p>The specific behavior of <code>prepare()</code>, <code>run()</code>, and <code>conclude()</code> depends on the sub-class of the target. For example, <code>run()</code> does nontrivial work in builders (stems and branches) but does nothing in all other classes. The <code>conclude()</code> method is where stems and patterns update the scheduler and spawn new buds and branches dynamically. Two of the most important responsibilities of <code>conclude()</code> are</p>
<ol style="list-style-type: decimal">
<li>Decrement the ranks of downstream targets in the priority queue.</li>
<li>Insert new targets dynamically.</li>
</ol>
<div id="decrement-the-ranks-of-downstream-targets-in-the-priority-queue-" class="section level2">
<h2 class="hasAnchor">
<a href="#decrement-the-ranks-of-downstream-targets-in-the-priority-queue-" class="anchor"></a>Decrement the ranks of downstream targets in the priority queue.</h2>
<p>The <code>conclude()</code> method decrements ranks in the priority queue to signal that downstream neighbors are one step closer to being ready to build. Most targets decrement all their downstream neighbors, but a pattern only decrement the neighbors that branch over it. This behavior for patterns is key because it allows future patterns to quickly define new branches before the current ones even start running, which contributes to parallel efficiency.</p>
</div>
<div id="insert-new-targets-dynamically-" class="section level2">
<h2 class="hasAnchor">
<a href="#insert-new-targets-dynamically-" class="anchor"></a>Insert new targets dynamically.</h2>
<p><code>targets</code> creates new targets dynamically when stems and patterns conclude. To illustrate, let us use the following example pipeline.</p>
<p><img src="orchestration/orchestration-start.png"></p>
<ul>
<li>The <code>data</code> and <code>data2</code> targets are starting datasets.</li>
<li>The <code>analysis</code> target maps over the rows of <code>data2</code> and performs a statistical analysis on each row. All analyses use the entirety of <code>data1</code>.</li>
<li>The <code>validation</code> target maps over the analyses to check each one for correctness.</li>
<li>The <code>summary</code> target aggregates and summarizes all the analyses and validations together.</li>
</ul>
<div id="insert-buds" class="section level3">
<h3 class="hasAnchor">
<a href="#insert-buds" class="anchor"></a>Insert buds</h3>
<p>Upon conclusion, <code>data2</code> creates buds to help its downstream neighbor <code>analysis</code> map over it later on. <code>data1</code> creates no buds because no pattern branches over it.</p>
<p><img src="orchestration/orchestration-data2.png"></p>
<p>To insert the buds, we:</p>
<ol style="list-style-type: decimal">
<li>Create a new junction with the names of the buds to create.</li>
<li>Create new bud objects, each containing a slice of <code>data2</code>’s return value.</li>
<li>Insert the buds into the pipeline object.</li>
</ol>
<p>We do not need to update the scheduler because the parent stem of the buds already completed. In other words, buds are born built.</p>
</div>
<div id="insert-branches" class="section level3">
<h3 class="hasAnchor">
<a href="#insert-branches" class="anchor"></a>Insert branches</h3>
<p>With the buds in place, the <code>analysis</code> pattern can now create branches.</p>
<p><img src="orchestration/orchestration-analysis.png"></p>
<p>As soon as these first branches are created, we can create the branches for <code>validation</code>. It does not matter if <code>analysis_5c77a278</code> and <code>analysis_3439bce3</code> are both still queued. In addition, as soon as <code>analysis_5c77a278</code> is built, <code>validation_0f7f2822</code> can start building regardless of whether <code>analysis_3439bce3</code> is complete. This is a major source of parallel efficiency.</p>
<p><img src="orchestration/orchestration-validation.png"></p>
<p>The fine details of the branching algorithm are as follows.</p>
<ol style="list-style-type: decimal">
<li>First we create a junction to describe the branches we will create. This branching specification depends on the type of pattern we have (map or cross) and the upstream dependencies of the pattern.</li>
<li>Create and insert those new branches into the pipeline.</li>
<li>Draw graph edges to connect the branches to their individual upstream dependencies (buds or branches).</li>
<li>Insert graph edges from the new branches to their parent pattern. Some targets may use the entire pattern in aggregate instead of iterating over individual branches, and this step makes sure all the branches are available for aggregation before a downstream target needs to use the aggregate.</li>
<li>Push the branches onto the priority queue. The rank for each branch is the number of upstream dependencies that still need to be checked or built. 1. Increment the priority queue ranks of all downstream non-branching targets by the number of new branches just created minus 1. This ensures all the branches complete before any target calls upon the entire aggregate of the pattern.</li>
<li>Register the branches as queued in the scheduler.</li>
<li>Push the pattern itself back onto the queue, where the priority queue rank now equals the number of branches minus a constant between 0 and 1. (The subtracted constant just ensures the pattern gets cleaned up as soon as possible.) This step ensures we revisit the pattern after all the branches are done. At that moment, we decrement the priority queue rank of every downstream target that depends on the entire aggregated pattern (as opposed to just a single branch). This behavior drives implicit aggregation, and it ensures we do not need a special <code><a href="https://dplyr.tidyverse.org/reference/combine.html">combine()</a></code> pattern to accompany <code>map()</code> and <code>cross()</code>.</li>
</ol>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by William Michael Landau.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.9000.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
